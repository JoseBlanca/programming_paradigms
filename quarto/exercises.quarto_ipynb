{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Procedural and OOP excersises\n",
        "\n",
        "## DNA sequence: procedural\n",
        "\n",
        "### Procedural approach\n",
        "\n",
        "Create functions to:\n",
        "\n",
        "- calculate sequence length\n",
        "- get the fastq and fasta representations of a sequence\n",
        "- reverse and complement a sequence.\n",
        "\n",
        "The sequence should be a tuple with two (name, and sequence) or three (name, sequence, and quality) fields.\n",
        "\n",
        "Here you have a test suite that should pass once you have implemented the functionality:\n"
      ],
      "id": "d86cb6f1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import unittest\n",
        "\n",
        "class SequenceTest(unittest.TestCase):\n",
        "    def test_seq_len(self):\n",
        "        seq = (\"seq1\", \"ATGC\")\n",
        "        assert calc_len(seq) == 4\n",
        "\n",
        "        seq = (\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert calc_len(seq) == 4\n",
        "\n",
        "        seq = (\"seq2\", \"ATGC\", [10, 20, 30])\n",
        "        try:\n",
        "            assert calc_len(seq) == 4\n",
        "            self.fail(\"Should have raised a ValueError\")\n",
        "        except ValueError:\n",
        "            pass\n",
        "\n",
        "    def test_to_fastq(self):\n",
        "        seq = (\"seq1\", \"ATGC\")\n",
        "        try:\n",
        "            assert to_fastq(seq)\n",
        "            self.fail(\"Should have raised a RuntimeError\")\n",
        "        except RuntimeError:\n",
        "            pass\n",
        "\n",
        "        seq = (\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert to_fastq(seq) == \"@seq2\\nATGC\\n+\\n+5?I\\n\"\n",
        "\n",
        "    def test_to_fasta(self):\n",
        "        seq = (\"seq1\", \"ATGC\")\n",
        "        assert to_fasta(seq) == \">seq1\\nATGC\\n\"\n",
        "        seq = (\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert to_fasta(seq) == \">seq2\\nATGC\\n\"\n",
        "\n",
        "    def test_reverse(self):\n",
        "        seq = (\"seq1\", \"aTGC\")\n",
        "        seq = reverse(seq)\n",
        "        assert seq[0] == \"seq1_rev\"\n",
        "        assert seq[1] == \"GCAt\"\n",
        "\n",
        "        seq = (\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        seq = reverse(seq)\n",
        "        assert seq[1] == \"GCAT\"\n",
        "        assert seq[2] == [40, 30, 20, 10]\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    unittest.main()"
      ],
      "id": "206aac6b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Object oriented approach\n",
        "\n",
        "Create a Sequence class with the following properties:\n",
        "\n",
        "- name\n",
        "- sequence\n",
        "- quality, this should be an array of integers from 0 to 60. Quality should be optional, it could be None.\n",
        "\n",
        "The class should have the methods to calculate:\n",
        "\n",
        "- the length of the sequence\n",
        "- to create a reverse and complementary sequence\n",
        "- to_fastq: it returns a str with the fastq representation of the sequence\n",
        "- to_fasta: it returns a str with the fasta representation of the sequence\n",
        "\n",
        "Here you have a test suite that should pass once you have implemented the functionality:\n"
      ],
      "id": "ed992bf8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import unittest\n",
        "\n",
        "class SequenceTest(unittest.TestCase):\n",
        "    def test_seq_creation(self):\n",
        "        seq = Seq(\"seq1\", \"ATGC\")\n",
        "        assert seq.name == \"seq1\"\n",
        "        assert seq.seq == \"ATGC\"\n",
        "        assert seq.qual is None\n",
        "\n",
        "        seq = Seq(\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert seq.name == \"seq2\"\n",
        "        assert seq.seq == \"ATGC\"\n",
        "        assert seq.qual == [10, 20, 30, 40]\n",
        "\n",
        "        try:\n",
        "            Seq(\"seq3\", \"ATGC\", [10, 20, 30])\n",
        "            self.failed(\"Should have raised a ValueError\")\n",
        "        except ValueError:\n",
        "            pass\n",
        "        try:\n",
        "            Seq(\"ATGC\")\n",
        "            self.failed(\"Should have raised a TypeError\")\n",
        "        except TypeError:\n",
        "            pass\n",
        "\n",
        "    def test_seq_len(self):\n",
        "        seq = Seq(\"seq1\", \"ATGC\")\n",
        "        assert len(seq) == 4\n",
        "\n",
        "        seq = Seq(\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert len(seq) == 4\n",
        "\n",
        "    def test_to_fastq(self):\n",
        "        seq = Seq(\"seq1\", \"ATGC\")\n",
        "        try:\n",
        "            assert seq.to_fastq()\n",
        "            self.fail(\"Should have raised a RuntimeError\")\n",
        "        except RuntimeError:\n",
        "            pass\n",
        "\n",
        "        seq = Seq(\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert seq.to_fastq() == \"@seq2\\nATGC\\n+\\n+5?I\\n\"\n",
        "\n",
        "    def test_to_fasta(self):\n",
        "        seq = Seq(\"seq1\", \"ATGC\")\n",
        "        assert seq.to_fasta() == \">seq1\\nATGC\\n\"\n",
        "        seq = Seq(\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        assert seq.to_fasta() == \">seq2\\nATGC\\n\"\n",
        "\n",
        "    def test_reverse(self):\n",
        "        seq = Seq(\"seq1\", \"aTGC\")\n",
        "        seq = seq.reverse()\n",
        "        assert seq.name == \"seq1_rev\"\n",
        "        assert seq.seq == \"GCAt\"\n",
        "\n",
        "        seq = Seq(\"seq2\", \"ATGC\", [10, 20, 30, 40])\n",
        "        seq = seq.reverse()\n",
        "        assert seq.seq == \"GCAT\"\n",
        "        assert seq.qual == [40, 30, 20, 10]\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    unittest.main()"
      ],
      "id": "25c83371",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Hints\n",
        "\n",
        "You can use the following dictionary to complement the IUPAC nucleotides:\n"
      ],
      "id": "78ccd058"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "COMPLEMENT_NUCL = {\n",
        "    \"A\": \"T\",\n",
        "    \"T\": \"A\",\n",
        "    \"C\": \"G\",\n",
        "    \"G\": \"C\",\n",
        "    \"N\": \"N\",\n",
        "    \"Y\": \"R\",\n",
        "    \"R\": \"Y\",\n",
        "    \"S\": \"S\",\n",
        "    \"W\": \"W\",\n",
        "    \"K\": \"M\",\n",
        "    \"M\": \"K\",\n",
        "    \"B\": \"V\",\n",
        "    \"V\": \"B\",\n",
        "    \"D\": \"H\",\n",
        "    \"H\": \"D\",\n",
        "}"
      ],
      "id": "ebb97aa5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Solutions\n",
        "\n",
        "You can get a working solution for the [OOP](files/sequence_oop.py) and [procedural](files/sequence_proc.py) approaches.\n",
        "\n",
        "# Functional programming excersises\n",
        "\n",
        "## Fastq statistics\n",
        "\n",
        "Write a program capable of calculating statistics of a fastq file.\n",
        "The statistics to calculate should be:\n",
        "\n",
        "- number of sequences\n",
        "- sequence length distribution\n",
        "- mean quality per sequence distribution\n",
        "- %GC per sequence distribution\n",
        "\n",
        "Take into account that the fastq files are usually very big, so write the program using a generator to read the sequences.\n",
        "\n",
        "The program should be able to read:\n",
        "\n",
        "- both [gzipped](https://en.wikipedia.org/wiki/Gzip) and umcompressed fastq files.\n",
        "- from [stdin](https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)) and standard files\n",
        "\n",
        "The result should be written in a [json](https://en.wikipedia.org/wiki/JSON) file.\n",
        "You can download an example fastq file in [here](files/seqs.fastq.gz).\n",
        "\n",
        "### Hints\n",
        "\n",
        "It is faster to read the file in binary mode than in text mode.\n"
      ],
      "id": "42893f1f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "    if fpath == \"-\":\n",
        "        fastq_fhand = sys.stdin.buffer\n",
        "    else:\n",
        "        fpath = Path(fpath)\n",
        "        if not fpath.exists():\n",
        "            print(f\"File {fpath} does not exist\")\n",
        "            sys.exit(1)\n",
        "        fastq_fhand = open(fpath, \"rb\")\n",
        "    fastq_fhand = io.BufferedReader(fastq_fhand)"
      ],
      "id": "5203833a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To know if a file is gzipped check its first two bytes, the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)) of a gzipped file is: \n"
      ],
      "id": "560844c5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gzip_magic_number = b\"\\x1f\\x8b\""
      ],
      "id": "68a12fef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "You can peek (read without advancing the pointer of the file) if you wrap the file handler in a [io.BufferedReader](https://docs.python.org/3/library/io.html#io.BufferedReader).\n"
      ],
      "id": "9c4f3708"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if not isinstance(fhand, io.BufferedReader):\n",
        "    fhand = io.BufferedReader(fhand)\n",
        "two_bytes = fastq_fhand.peek(2)[:2]"
      ],
      "id": "4a6c538f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To open gzipped files use the gzip module.\n"
      ],
      "id": "a360d48a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fhand = gzip.open(fhand, \"rb\")"
      ],
      "id": "ea8b1180",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Python has a module in the standar library to read and write [json](https://docs.python.org/3/library/json.html) files.\n",
        "\n",
        "### Test suite\n"
      ],
      "id": "b8fd5921"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import unittest\n",
        "\n",
        "class TestFastqStats(unittest.TestCase):\n",
        "    def test_calc_fastq_stats(self):\n",
        "        fastq = b\"@seq1\\nATGC\\n+\\nIIII\\n\"\n",
        "        fastq_fhand = io.BytesIO(fastq)\n",
        "        out_stats_fhand = io.StringIO()\n",
        "        calc_fastq_stats(fastq_fhand, out_stats_fhand)\n",
        "        out_stats = json.loads(out_stats_fhand.getvalue())\n",
        "        self.assertEqual(out_stats[\"num_seqs\"], 1)\n",
        "        self.assertEqual(out_stats[\"seq_len_distrib\"], {\"4\": 1})\n",
        "        self.assertEqual(out_stats[\"gc_distrib\"], {\"50\": 1})\n",
        "        self.assertEqual(out_stats[\"mean_qual_distrib\"], {\"40\": 1})"
      ],
      "id": "1696e276",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Solution\n",
        "\n",
        "If you want, you could take a peak of a possible [solution](files/calc_fastq_stats.py) that uses a generator to read the sequences.\n",
        "\n",
        "## Count Kmers\n",
        "\n",
        "Write a program that, given a fastq file, counts the [kmers](https://en.wikipedia.org/wiki/K-mer) found in the DNA sequences.\n",
        "\n",
        "It should write down two files:\n",
        "\n",
        "- A json file with the kmer abundance distribution.\n",
        "- A text file with every kmers\n",
        "\n",
        "The text file should include every kmer with a count higher than 1.\n",
        "In each line there should be the kmer sequence and the number of times that the kmer has been found in the sequences.\n",
        "The kmer distribution abundance refers to the number of kmers that have been found 1, 2, 3 o n number of times.\n",
        "For instance, 3 kmers have been found to be present 42 times in the sequences, 30 kmers 5 times, etc.\n",
        "Here you have a test with the expected output:\n"
      ],
      "id": "b5cc3953"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import unittest\n",
        "\n",
        "class TestKmerCounting(unittest.TestCase):\n",
        "    def test_kmer_counting(self):\n",
        "        fhand = io.BytesIO(\n",
        "            b\"@seq1\\nACTGGATCTTGCC\\n+\\nIIIIIIIIIII\\n@seq2\\nACTGGATATGCG\\n+\\nIIIIIIIIIIII\\n@seq3\\nTTCATGC\\n+\\nIIIIIII\\n\"\n",
        "        )\n",
        "        kmers_fhand = io.StringIO()\n",
        "        stats_fhand = io.StringIO()\n",
        "        count_kmers(fhand, kmers_fhand, stats_fhand, 5)\n",
        "        assert kmers_fhand.getvalue() == \"ACTGG\\t2\\nCTGGA\\t2\\nTGGAT\\t2\\n\"\n",
        "\n",
        "        assert json.loads(stats_fhand.getvalue()) == {\"2\": 3, \"1\": 14}"
      ],
      "id": "afa3b2fd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "You can download a gzipped [fastq file](files/seqs.fastq.gz) with 1000 sequences.\n",
        "\n",
        "### Hints\n",
        "\n",
        "Parse the fastq file creating a generator, otherwise you would fill out your computer memory when reading millions of sequences.\n",
        "\n",
        "You can use a [Counter](https://docs.python.org/3/library/collections.html#collections.Counter) object to count the kmers.\n",
        "\n",
        "Remember the hints given in the calculate fastq statistics regarding opening gzipped and not compressed fastq files."
      ],
      "id": "93420896"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/jose/webs/bioinf/boostrap_and_build/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}